//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2019.05.22 at 11:20:22 PM BST 
//


package com.mei.ergosurgeon.load.data.entities;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.mei.ergosurgeon.load.business.AvroFiles;
import com.mei.ergosurgeon.load.business.KafkaTemplates;
import com.mei.ergosurgeon.load.common.SegmentEnum;
import com.mei.ergosurgeon.load.data.entities.custom.KafkaTopic;
import com.mei.ergosurgeon.load.data.entities.custom.Quaternion;
import com.mei.ergosurgeon.load.data.entities.custom.Vector;
import org.springframework.kafka.core.KafkaTemplate;

import javax.xml.bind.annotation.*;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

@XmlAccessorType(XmlAccessType.FIELD)
@XmlRootElement(name = "frame")
public class Frame implements KafkaTopic<Frame> {

    @JsonProperty
    @XmlElement(required = true)
    protected String orientation;

    @XmlElement(required = true)
    protected String position;
    protected String velocity;
    protected String acceleration;
    protected String angularVelocity;
    protected String angularAcceleration;
    protected String sensorAcceleration;
    protected String sensorAngularVelocity;
    protected String sensorMagneticField;
    protected String sensorOrientation;
    protected String jointAngle;
    protected String jointAngleXZY;
    protected String centerOfMass;
    protected String marker;
    @XmlAttribute(name = "time", required = true)
    protected String time;
    @XmlAttribute(name = "index", required = true)
    protected String index;
    @XmlAttribute(name = "tc")
    protected String tc;
    @XmlAttribute(name = "ms")
    protected String ms;
    @XmlAttribute(name = "type", required = true)
    protected String type;

    private List<Quaternion> orientations;
    private List<Vector> positions;

    public List<Quaternion> getOrientations() {
        return orientations;
    }

    public void setOrientations(List<Quaternion> orientations) {
        this.orientations = orientations;
    }

    public List<Vector> getPositions() {
        return positions;
    }

    public void setPositions(List<Vector> positions) {
        this.positions = positions;
    }

    public String getOrientation() {
        return orientation;
    }

    public void setOrientation(String value) {
        this.orientation = value;
    }

    public String getPosition() {
        return position;
    }

    public void setPosition(String value) {
        this.position = value;
    }

    public String getVelocity() {
        return velocity;
    }

    public void setVelocity(String value) {
        this.velocity = value;
    }

    public String getAcceleration() {
        return acceleration;
    }

    public void setAcceleration(String value) {
        this.acceleration = value;
    }

    public String getAngularVelocity() {
        return angularVelocity;
    }

    public void setAngularVelocity(String value) {
        this.angularVelocity = value;
    }

    public String getAngularAcceleration() {
        return angularAcceleration;
    }

    public void setAngularAcceleration(String value) {
        this.angularAcceleration = value;
    }

    public String getSensorAcceleration() {
        return sensorAcceleration;
    }

    public void setSensorAcceleration(String value) {
        this.sensorAcceleration = value;
    }

    public String getSensorAngularVelocity() {
        return sensorAngularVelocity;
    }

    public void setSensorAngularVelocity(String value) {
        this.sensorAngularVelocity = value;
    }

    public String getSensorMagneticField() {
        return sensorMagneticField;
    }

    public void setSensorMagneticField(String value) {
        this.sensorMagneticField = value;
    }

    public String getSensorOrientation() {
        return sensorOrientation;
    }

    public void setSensorOrientation(String value) {
        this.sensorOrientation = value;
    }

    public String getJointAngle() {
        return jointAngle;
    }

    public void setJointAngle(String value) {
        this.jointAngle = value;
    }

    public String getJointAngleXZY() {
        return jointAngleXZY;
    }

    public void setJointAngleXZY(String value) {
        this.jointAngleXZY = value;
    }

    public String getCenterOfMass() {
        return centerOfMass;
    }

    public void setCenterOfMass(String value) {
        this.centerOfMass = value;
    }

    public String getMarker() {
        return marker;
    }

    public void setMarker(String value) {
        this.marker = value;
    }

    public String getTime() {
        return time;
    }

    public void setTime(String value) {
        this.time = value;
    }

    public String getIndex() {
        return index;
    }

    public void setIndex(String value) {
        this.index = value;
    }

    public String getTc() {
        return tc;
    }

    public void setTc(String value) {
        this.tc = value;
    }

    public String getMs() {
        return ms;
    }

    public void setMs(String value) {
        this.ms = value;
    }

    public String getType() {
        return type;
    }

    public void setType(String value) {
        this.type = value;
    }

    public Frame process() {
        //TODO Normalize the frames.

        //TODO Fazer as ligações entre os rotulos, e classificar as posições em cada instante, passar para objectos dto,
        //não quero trabalhar com tanto lixo

        Float[] orientations = Stream.of(getOrientation().split(" ")).map(Float::new).toArray(Float[]::new);
        int i = 0;
        int x = 0;
        List<Quaternion> auxOrientations = new ArrayList<>(orientations.length / 4);

        for (; i < orientations.length; i += 4)
            auxOrientations.add(new Quaternion(Long.parseLong(time), orientations[i], orientations[i + 1], orientations[i + 2], orientations[i + 3], SegmentEnum.obtain(x++)));

        setOrientations(auxOrientations);

        Float[] positions = Stream.of(getPosition().split(" ")).map(Float::new).toArray(Float[]::new);
        i = 0;
        x = 0;
        List<Vector> auxPositions = new ArrayList<>(positions.length / 3);

        for (; i < positions.length; i += 3)
            auxPositions.add(new Vector(Long.parseLong(time), positions[i], positions[i + 1], positions[i + 2], SegmentEnum.obtain(x++)));

        setPositions(auxPositions);
        //send(this);

        return this;
    }

    @Override
    public String getTopic() {
        return "frame";
    }

    @Override
    public KafkaTemplate<Object, Frame> getKafkaTemplate() {
        return KafkaTemplates.getKafkaFrameTemplate();
    }

    @Override
    public File getAvroFile() {
        return AvroFiles.getAvroFrameSchema();
    }
}
